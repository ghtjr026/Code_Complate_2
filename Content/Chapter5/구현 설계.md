5장 구현 설계

o 소프트웨어의 주요 기술적 의무는 복잡성을 관리하는 것이다. 이것은 단순함에 초점을 맞춘 설계로 큰 도움을 받을 수 있다.

o 단순함은 두 가지 일반적인 방법으로 달성할 수 있다. 한 번에 뇌에서 처리해야 하는 본질적인 복잡성의 양을 최소화하는 것과 부수적인 복잡성이 불필요하게 증가하지 않도록 한느 것이 그것이다.

o 설계는 발견적 학습이다. 한 가지 방법론에만 독단적으로 집착하면 독창성과 프로그램에 해가 된다.

o 좋은 설계는 반복적이다. 여러 번 시도할수록 최종 설계는 더 좋아질 것이다.

o 정보 은닉은 매우 유용한 개념이다. “무엇을 숨겨야 하지?”라는 질문이 해결하기 어려운 설계상의 문제를 해결해준다.

o 설계에 대한 수많은 유용하고 흥미로운 정보를 다른 자료에서도 구할 수 있다. 이 책에 소개된 내용은 빙산의 일각에 불과하다.

 

설게의 발견적 학습에 대한 요약

a. 일관성 있는 추상화를 구성하자

루틴 인터페이스 수준, 클래스 인터페이스 수준, 패키지 인터페이스 수준의 단계적인 추상화를 제공함으로써 더 빠르고 안전하게 프로그래밍할 수 있게 해준다.

 

b. 세부사항을 캡슐화하라

추상화는 객체를 높은 수준에서 볼 수 있도록 하고 캡슐화는 다른 수준에서 해당 객체를 특정 수준 이상으로 볼 수 없도록 하는 것이다.

 

c. 가능할 때 상속하라

상속은 추상화와 시너지 효과가 있다. 추상화는 서로 다른 수준에서 객체를 다룬다. 상속은 프로그래밍을 단순화한다. 객체지향 언어는 상속과 다형성을 지원한다. 다형성이란 객체의 종류와 상관없이 같은 연산을 지원하는 언어의 능력이다. 예를 들어 여러 종류의 문이 있을 때, Open과 Close와 같은 연산은 문의 종류와 상관없이 적용될 수 있다.

 

d. 비밀을 숨겨라 ( 정보 은닉 )

클래스 설계에서 가장 중요한 작업 중 하나는 어떤 기능을 클래스 외부로 알리고 어떤 기능을 비밀로 남길지 결정하는 것이다. 정보 은닉은 숫자 상수 대신 이름 상수(named constant)를 사용하는 것부터 데이터 타입의 생성(e.g. Int형을 typedef로 변경하여 사용하는 것)을 비롯해 클래스 설계, 루틴 설계, 서브 시스템 설계에 이르기까지 모든 설계수준에서 유용하다.

은닉의 두 가지 분류

- 특별하게 관심이 없는 경우에 고민할 필요가 없도록 복잡성을 감추는 것 ( ? )

- 변경이 발생했을 때 그 효과가 일부에만 영향을 미치도록 변경의 원인을 감추는 것

은닉의 장애물

- 정보의 지나친 배분

- 순환 의존성 : 클래스 A에 있는 루틴이 클래스 B에 있는 루틴을 호출하고 클래스 B에 있는 루틴이 클래스 A에 있는 루틴을 호출하는 경우

- 전역 데이터로 오해받는 클래스 데이터

- 성능 손해

e. 변경될 것 같은 영역을 찾아라

변경 사항을 수용하는 것은 좋은 프로그램 설계에서 가장 어려운 부분이다. 변경의 효과가 한 루틴이나 클래스, 패키지에 제한되도록 불안정한 영역을 고립시키는 것이 목표다.

- 변경될 것처럼 보이는 항목을 찾는다. -> 요구사항 개발 단계에서 변경 가능성이 있는 것의 목록과 변경이 일어날 확률을 담고 있을 것이다. 요구사항 분석에서 변경 가능성을 다루지 않았다면 어느 프로젝트에서나 변경될 가능성이 큰 영역에 대한 이어지는 내용을 살펴본다.

- 변경될 것 같은 항목을 분류한다. -> 변경되기 쉬운 요소를 고유한 클래스로 분류하거나 함께 변경될 수 있는 다른 요소들과 함께 고유한 클래스로 분류한다.

- 변경될 것처럼 보이는 항목을 고립시킨다. -> 잠재적인 변경에 영향을 받지 않는 상호 클래스 인터페이스를 설계하고, 그러한 변화가 해당 클래스의 내부에 제한되어 외부는 영향을 받지 않도록 인터페이스를 설계한다. 변경된 클래스를 사용하는 클래스는 변경이 발생했다는 사실을 몰라야 하며, 클래스의 인터페이스가 자신의 비밀을 보호해야 한다.

변경될 가능성이 큰 영역

- 비즈니스 규칙

- 하드웨어 의존성

하드웨어 의존성을 자체적인 서브시스템 또는 클래스로 고립시킨다. 특정 하드웨어와 상호작용을 흉내 내는 소프트웨어를 작성하고 하드웨어가 불안정하거나 사용 불가능할 때 하드웨어 인터페이스의 서브시스템을 시뮬레이터로 사용하게 만들고 나서 하드웨어를 사용할 준비가 되면 시뮬레이터에서 하드웨어 인터페이스 서브시스템을 빼고 그 서브시스템을 하드웨어에 연결하면 된다.

- 입력과 출력

- 표준을 따르지 않는 언어 기능

대부분의 언어 구현체는 편리하지만, 표준을 따르지 않는 확장 기능을 포함한다. 그러한 확장 기능은 환경에 따라 지원되지 않을 수도 있기때문에 양날의 검과 같다.

- 어려운 설계 및 구현 부분

- 상태 변수

상태 변수는 프로그램의 상태를 나타내고 다른 데이터보다 자주 변경되는 경향이 있다. 상태 변수를 사용할 때는 유연성과 가독성을 고려한다.

- 데이터 크기 제약

f. 결합을 느슨하게 유지하라

결합의 기준

- 크기

크기는 모듈 사이의 연결 횟수를 의미한다. 결합에서는 작은 인터페이스를 갖는 모듈이 다른 모듈에 연결하기가 상대적으로 쉽기 때문에 가능하면 작은 것이 좋다. 매개변수를 하나만 받는 루틴이 여섯 개의 매개변수를 받는 루틴보다 그것을 호출하는 모듈에 느슨하게 결합되어 있다.

- 가시성

가시성은 두 모듈 간의 연결이 얼마나 명시적인지를 의미한다. 매개변수 목록에 데이터를 전달하는 것은 분명하게 연결하는 것이기 때문에 좋다.

- 유연성

유연성은 얼마나 쉽게 모듈 사이의 연결을 변경할 수 있는지를 의미한다. 이상적으로는 피복 전선과 인두 같은 것보다는 컴퓨터에 있는 USB 연결 장치 같은 것을 원할 것이다.

결합의 종류

- 간단한 데이터 매개변수 결합

두 모듈 사이에서 전달되는 모든 데이터가 기본 데이터형이고 모든 데이터가 매개변수로 전달된다면 두 모듈은 단순-데이터-매개변수로 결합된 것이다.

- 간단한 객체 결합

모듈이 객체를 인스턴스화한다면 그 모듈은 객체에 단순-객체로 결합된 것이다.

- 객체 매개변수 결합

Object1이 Object2에게 Object3을 넘겨달라고 요구한다면 두 모듈은 서로에 대해서 객체-매개변수로 결합한 것이다.

g. 일반적으로 널리 사용되는 디자인 패턴을 찾아라.