22장 개발자 테스트

o 개발자에 의한 테스트는 완전한 테스트 전략을 위한 핵심적인 부분이다. 독립적인 테스트도 중요하지만, 그 부분은 이 책의 범위를 벗어난다.

o 코드를 작성하기 전에 테스트 케이스를 작성하는 것과 코드를 작성한 후에 테스트 케이스를 작성하는 것은 시간과 노력 면에서 같지만, 전자가 결함-발견-디버그-수정 주기를 줄여준다.

o 아무리 여러 가지 테스트를 고려해 봐도 테스트는 좋은 소프트웨어-ㅠᅟᅮᆷ질 프로그램의 한 부분일 뿐이다. 요구사항과 설계에서 결함을 최소화하는 방법을 포함한 고급 개발 방법도 테스트만큼은 중요하다. 협력적인 개발 기법도 테스트만큼이나 오류를 발견하는 데 효과적이며 다른 오류를 검출한다.

o 결정적으로 기초 테스트와 데이터 흐름 분석, 경계 분석, 나쁜 데이터, 좋은 데이터를 사용하여 많은 테스트 케이스를 생성할 수 있다. 오류 추측으로 테스트 케이스를 추가로 생성할 수 있다.

o 오류는 오류를 유발할 가능성이 있는 몇 개의 클래스와 루틴에 쏠려있는 경향이 있다. 오류를 유발할 가능성이 있는 코드를 찾아서 재설계한 다음 다시 작성한다.

o 테스트 데이터가 테스트하는 코드보다 오류를 더 자주 발생시키는 경향이 있다. 그러한 테스트 데이터 오류는 코드를 향상시키지 않고 시간을 낭비하게 하므로 프로그래밍 오류보다 더 짜증 난다. 코드를 개발하는 것 못지않게 테스트 개발에 주의를 기울여 그런 문제를 피하도록 한다.

o 자동 테스트는 일반적으로 유용하며 회귀 테스트에서는 필수적이다.

o 규칙적으로 진행하고 측정하고 테스트를 향상시키기 위해서 배운 것을 사용하는 것이 테스트 프로세스를 향상시키는 최고의 방법이다.

 

개발자가 하는 테스트

a. 단위 테스트

- 한 명의 개발자나 팀이 작성한 클래스나 루틴, 작은 프로그램을 실행하는 것으로, 완성된 시스템과는 별개로 테스트한다.

b. 컴포넌트 테스트

- 여러 개발자나 개발팀이 참여하는 클래스, 패키지, 소형 프로그램, 다른 프로그램의 요소를 실행하는 것으로, 더 완전한 시스템과 별개로 테스트한다.

c. 통합 테스트

- 여러 개발자나 개발팀이 만든 클래스나 패키지, 컴포넌트, 서브시스템을 두 개 이상 결합해 실행하는 것이다. 이와 같은 테스트는 전형적으로 테스트해야 하는 클래스가 두 개가 되는 순간 시작해서 전체 시스템 개발이 완료될 때까지 지속적으로 수행한다.

d. 회귀 테스트

- 이전에 통과했던 테스트 집합을 가지고 소프트웨어에 있는 결함을 찾기 위해 이전에 실행했던 테스트 케이스를 반복하는 것이다.

e. 시스템 테스트

- 다른 소프트웨어와 하드웨어 시스템과의 통합을 포함한 최종 환경에서 소프트웨어를 실행하는 것이다. 이 테스트는 보안과 성능, 자원 손실, 시간 문제, 저수준 통합에서는 테스트할 수 없는 문제를 테스트한다.

 

개발자 테스트의 한계

a. 개발자 테스트는 “깨끗한 테스트”가 되기 쉽다.

- 개발자들은 코드가 깨지는 다양한 상황에 대해서 테스트(더러운 테스트)를 하기보다는 코드가 작동하는지 보기 위해서 테스트(깨끗한 테스트)하는 경향이 있다.

b. 개발자 테스트는 테스트 커버리지를 낙관적으로 바라보는 경향이 있다.

- 일반적인 개발자들이 스스로 95%의 테스트 커버리지를 달성한다고 믿지만, 전형적으로 최고 80%에서 최저 30%, 평균 50%에서 60% 정도의 테스트 커버리지를 달성한다.

c. 개발자 테스트는 좀 더 정교한 테스트 커버리지를 건너뛰는 경향이 있다.

- 대부분의 개발자는 “100% 커버리지”라고 알려진 테스트 커버리지를 적합한 것으로 본다.

※ 테스트 커버리지 : 시스템ㆍ소프트웨어의 논리적 구조가 Test Suite에 의해 테스트된 정도

 

여러 가지 교묘한 테스트 방법

a. 구조적인 기초 테스트

- 기본 개념은 프로그램에 있는 각 명령문을 적어도 한 번은 테스트해야 한다는 것이다.

b. 데이터 흐름 테스트

- 데이터 사용이 적어도 제어 흐름만큼 오류를 유발할 수 있다는 개념에 기반을 둔 테스트이다. 데이터는 아래 세 가지 상태 중 한 가지로 존재할 수 있다.

ㄱ. 정의 : 데이터가 초기화되었지만, 아직 사용되지 않았다.

ㄴ. 사용 : 데이터가 루틴의 인자로서 계산되거나 다른 무언가를 위해서 사용되었다.

ㄷ. 삭제 : 데이터가 정의되었지만 어떤 방식으로 정의가 해제되었다. 가령 데이터가 포인터라면 아마도 포인터가 해제되었을 것이다.

c. 등가 분할

- 좋은 테스트 케이스는 가능한 입력 데이터의 넓은 부분을 다룬다. 두 테스트 케이스가 정확하게 같은 오류를 제거한다면 그중 하나만 필요하다. “등가 분할” 개념은 이러한 개념을 형식화하여 필요한 테스트 케이스의 수를 줄이는 데 도움을 준다.

d. 오류 추측

- 좋은 개발자는 형식적인 테스트 기법과 더불어 덜 형식적이고 경험적인 여러 가지 기법을 사용해 자신의 코드에 있는 오류를 들춰낸다. 한 가지 경험적인 기법은 오류를 추측하는 기법이다.

e. 경계 분석

- 테스트가 가장 유용한 영역 중 하나는 경제 조건, 즉 하나 차이로 인한 오류다. num을 써야할 때 num – 1을 쓰고, >을 써야할 때 >=라고 쓰는 것이 가장 흔한 실수다.

ㄱ. 복합 경계

- 경계 분석은 허용 가능한 최댓값과 최솟값에도 적용된다.

 

전형적인 오류

오류의 분류

a. 대부분의 오류가 발생하는 범위는 상당히 제한되어 있다.

- 어떤 연구에서 85%의 오류가 하나의 루틴 안에서 수정될 수 있다는 것을 발견했다.

b. 많은 오류가 구현 범위 밖에 있다.

- 97번의 인터뷰를 진행한 연구자들은 가장 일반적인 오류의 세 가지 원인이 응용 프로그램 도메인에 대한 빈약한 지식, 요구사항의 변동과 모순, 의사소통과 협동의 실패라는 것을 발견했다.

c. 대부분의 구현 오류는 프로그램의 잘못이다.

d. 오타는 뜻밖에 많이 발생하는 문제다.

e. 설계를 잘못 이해하는 것은 프로그램의 오류에 대한 연구에서 계속해서 나타나는 주제다.

f. 대부분의 오류는 수정하기 쉽다.

g. 자신이 속한 조직의 오류에 대한 경험을 측정하는 것은 좋은 생각이다.