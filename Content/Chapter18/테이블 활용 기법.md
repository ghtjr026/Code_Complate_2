18장 테이블 활용 기법

o 테이블은 복잡한 논리 코드와 상속 구조에 대한 대안을 제공한다. 프로그램의 논리나 상속 트리가 혼란스럽다고 생각한다면 참조 테이블을 사용하여 단순화할 수 있는지 확인해 본다.

o 테이블을 사용할 때 고려할 한 가지 핵심 사항은 테이블 접근법을 결정하는 것이다. 직접 접근 방식이나 인덱스 접근 방식, 단계적 접근 방식을 사용하여 테이블에 접근할 수 있다.

o 테이블을 사용할 때는 테이블에 무엇을 입력할지 결정하는 게 매우 중요하다.

 

테이블을 활용한 기법의 두 가지 문제점

첫째, 테이블에 있는 엔트리를 어떻게 참조할 것인가.

둘째, 테이블을 활용한 기법을 사용하면 테이블에 무엇을 저장해야 할지 설명해야 한다.

 

가) 직접 접근 방식

월별 일수 예제

평범한 방법으로 월별 일수를 구하는 비주얼 베이직 예제

if ( month = 1) then

days = 31

else if ( month = 2 ) then

days = 28

else if ( month = 3 ) then

days = 31

...

else if ( month = 12 ) then

days = 31

end if

 

우아한 방법으로 월별 일수를 구하는 비주얼 베이직 예제

‘ “월별 일수” 데이터 테이블을 초기화 한다.

Dim daysPerMonth() As Integer = _

{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }

 

유연한 메시지 형식 예제

파일에 저장된 메시지를 출력하는 루틴을 작성하고 있다고 하자. 파일은 보통 500개의 메시지를 포함하고 있으며 각 파일에는 20가지 종류의 메시지가 들어있다. 메시지는 부이(정의: 배의 안전 항행을 위하여 설치하는 항로 표지의 하나)로부터 발생하고 수온과 부이의 위치 등을 제공한다.

각 메시지는 필드를 여러 개 갖고 있으며 메시지의 종류를 나타내는 ID를 포함하고 있는 헤더로 시작한다.

메시지 형식은 고객에 따라 변하기 쉽다. 그렇다고 고객이 메시지 형식을 변경하지 않도록 할 수도 없다.



아래는 메시지 예
|부이 온도 메시지 ID|부이 해류 메시지 ID|부이 위치 메시지 ID|
|---|---|---|
|평균 온도(부동 소수점)\n 온도 범위(부동 소수점)\n 샘플 수(정수)\n 위치(문자열)\n 측정 시간(시간)|위도의 변화(부동 소수점)\n 경도의 변화(부동 소수점)\n 측정 시간(시간)|위도(부동 소수점)\n 경도(부동 소수점)\n 깊이(정수)\n 측정 시간(시간)|


테이블을 활용한 접근법

- 메시지를 읽는 루틴은 각 메시지 헤더를 읽고 ID를 해석하고 Message 배열에서 메시지 설명을 찾은 다음 메시지를 해석하기 위해서 항상 같은 루틴을 호출하는 루프로 구성된다.

이러한 접근법을 사용하려면 먼저 메시지 종류와 필드의 형을 나열한다.

메시지 데이터형을 정의하는 C++ 예제

enum FieldType

{

FieldType_FloatingPoint,

FieldType_Integer,

FieldType_String,

FieldType_TimeOfDay,

FieldType_Boolean,

FieldType_BitField

FieldType_Last = FieldType_BitField

};

20가지 메시지에 대한 출력 루틴 코드를 직접 작성하는 대신 부동 소수점, 정수, 문자열 등과 같은 각 기본 데이터형을 출력하는 루틴을 작성하면 된다.

 

While 출력할 필드가 있을 때까지

메시지 설명으로부터 필드 타입을 가져온다

case ( 필드 타입 )

of ( 부동 소수점 )

부동 소수점 값을 읽는다

필드 레이블을 출력한다

부동 소수점 값을 출력한다

of ( 정수 )

정수 값을 읽는다

필드 레이블을 출력한다

정수 값을 출력한다

of ( 문자열 )

문자열 값을 읽는다

필드 레이블을 출력한다

문자열 값을 출력한다

of ( 시간 )

시간 값을 읽는다

필드 레이블을 출력한다

시간 값을 출력한다

of ( 불린 )

단일 플래그 값을 읽는다

필드 레이블을 출력한다

단일 플래그 값을 출력한다

of ( bir field )

비트 필드 값을 읽는다

필드 레이블을 출력한다

비트 필드 값을 출력한다

End Case

End While

이 루틴은 여섯 가지 필드 타입을 다루고 있고 모든 종류의 메시지를 처리한다.

 

객체 형식을 구성하는 C++ 예제

c;ass AbstractField

{

public:

virtual void ReadAndPrint( string, FileStatus & ) = 0;

};

 

class FloatingPointField : public AbstractField

{

public:

virtual void ReadAndPrint( string, FileStatus & ) {

...

}

};

 

class IntegerFieId ...

class StringField ...

이 코드는 문자열 매개변수와 FileStatus 매개변수를 가진 각 클래스에 대한 맴버 루틴을 선언한다.

 

각 객체 형식을 보관할 테이블을 구성하는 C++ 예제

AbstractField* field[ Field_Last + 1 ];

객체 테이블을 구성하는 마지막 단계는 field 배열에 객체의 이름을 할당하는 것이다.

 

객체 목록을 구성하는 C++ 예제

field[ Field_FloatingPoint ] = new FloatingPointField();

field[ Field_Integer ] = new IntegerField();

field[ Field_String ] = new StringField();

field[ Field_TimeOfDay ] = new TimeOfDayField();

field[ Field_Boolean ] = new BooleanField();

field[ Field_BitField ] = new BitFieldField();

이 코드는 FloatingPointField를 비롯한 다른 구별자가 AbstractField 형을 상속받았다고 가정하고 있다. 객체를 배열의 요소에 할당하면 특정한 종류의 객체를 직접 사용하는 대신 배열의 요소를 참조하여 정확한 ReadAndPrint() 루틴을 호출할 수 있다.

 

테이블에서 객체와 맴버 루틴을 참조하는 C++ 예제

fieldIdx = 1;

while( ( fieldIdx <= nuFieldsInMessage ) && ( fileStatus == OK) )

{

fieldType = fieldDescription[ fieldIdx ].FieldType;

fieldName = fieldDescription[ fieldIdx ].FieldName;

field[ fieldType ].ReadAndPrint( fieldName, fileStatus );

fieldIdx++;

}

case 문을 객체 테이블로 대체하면 이 코드만으로 같은 기능을 구현할 수 있다. 놀랍게도 이 코드만 있으면 논리적 접근 방식에서 작성했던 20개의 루틴을 대체할 수 있다. 메시지를 기술한 내용을 파일에서 읽어 올 때 새로운 필드형이 있는 경우만 아니라면 새로운 메시지 형식이 추가된다고 하더라도 코드를 변경할 필요가 없다.

 

참조 키 변경하기

a. 키값을 곧바로 사용할 수 있도록 정보를 복사한다.

b. 곧바로 사용할 수 있도록 키값을 변환한다.

- 키값으로 사용할 데이터에 함수를 적용하여 곧바로 사용할 수 있는 키값으로 변환시키는 것이다. 변환 함수를 작성하려면 키값으로 사용하고자 하는 데이터의 패턴을 인식하는 것이 중요하다.

c. 키 변환 기능을 루틴으로 작성한다.

- 테이블에 접근하기 위해서 키로 사용하기 위해서 데이터를 변경해야 한다면 데이터를 키로 변환하는 연산을 루틴으로 작성하라. 루틴이 위치에 상관없이 항상 같은 결과를 반환해야 한다. 그래야 변환 연산을 변경할 때 수정하기 쉽다. KeyFromAge()와 같은 좋은 루틴 이름을 사용하면 수학적인 계산의 목적을 분명히 할 수 있다.

 

나) 인덱스 접근 방식

때때로 간단한 수학적인 변환만으로 킷값을 변환하는 것이 충분하지 않은 경우가 있다. 그러한 경우 인덱스 접근 방식이 적합하다.

인덱스를 사용하면 인덱스 테이블에 있는 키를 참조하기 위해서 원본 데이터를 사용하고 참조하고자 한느 실제 데이터를 참조하기 위해서 인덱스 테이블에 있는 값을 사용한다.

 

인덱스 접근 방식의 장점

첫째, 주 참조 테이블에 있는 각 엔트리가 크다면 많은 공간이 낭비되는 주 참조 테이블을 만드는 대신 많은 공간을 낭비되는 인덱스 배열을 만드는 것이 공간을 더 적게 사용한다. 예를 들어, 주 참조 테이블이 엔트리당 100바이트를 차지하고 인덱스는 엔트리당 2바이트를 차지한다고 가정해 보자. 그리고 주 참조 테이블에는 100개의 엔트리가 있고 1만 개의 값으로 데이터에 접근할 수 있다고 하자. 그런 경우, 1만 개의 엔트리를 갖는 인덱스를 만들거나 1만 개의 엔트리를 갖는 주 데이터 맴버를 만드는 방법을 선택할 수 있다. 인덱스를 사용하면 전체 메모리 사용량은 3만 바이트가 된다. 인덱스 구조를 사용하지 않고 메인 테이블에서 공간을 사용한다면 전체 메모리 사용량은 100만 바이트가 된다.

둘째, 인덱스를 사용함으로써 공간을 절약할 수 없다고 하더라도 주 테이블에 있는 엔트리보다 인덱스에 있는 엔트리를 다루는 것이 더 간단한 경우가 있따는 것이다. 가령 직원의 이름과 입사 날짜, 월급 정보를 저장하는 테이블이 있다면 직원의 이름이나 입사 날짜, 월급을 통해 테이블에 접근하게 인덱스를 만들 수 있다.

셋째, 일반적인 테이블 참조 방법이 제공하는 유지보수 용이성이다. 테이블에 입력된 데이터는 코드로 작성된 데이터보다 유지보수 하기가 쉽다. 프로그램을 최대한 유연하게 만들고 싶다면 인덱스 접근 코드를 별도의 루틴으로 작성한 다음 일련번호에서 테이블 키를 가져올 때 해당 루틴을 호출한다. 테이블을 변경할 때 인덱스 접근 코드를 바꾸거나 다른 테이블 참조 방식으로 전환할 수도 있다. 어느 방식이든 인덱스를 통한 접근 방식을 프로그램의 여러 곳에서 사용하지 않으면 더 쉽게 변경할 수 있을 것이다.

 

다) 단계적 접근 방식

단계적 테이블 참조를 수행하는 비주얼 베이직 예제

‘ 학점 테이블을 위한 데이터를 구성한다.

Dim rangeLimit() As Double = { 20.0, 65.0, 75.0, 90.0, 100.0 }

Dim grade() As String = { “F”, “D”, “C”, “B”, “A” }

maxGradeLevel = grade.Length – 1

...

 

‘ 학생의 성적에 따라서 학생에게 학점을 배정한다.

gradeLevel = 0

studentGrade = “A”

While ( ( studentGrade = “A” ) and ( gradeLevel < maxGrafeLevel ) )

If ( studentScroe < rangeLimit( gradeLevel ) ) Then

stdentGrade = grade( gradeLevel )

End If

gradeLevel = gradeLevel + 1

Wend

- 이 예제는 간단하지만, 여러 학생들과 여러 가지 학점 부여 방식과 학점 부여 방식의 변화를 처리하기 위해 쉽게 일반화할 수 있다.

이 접근 방식이 다른 테이블을 활용하는 방식보다 더 나은 점은 불규칙한 데이터를 잘 다룬다는 점이다. 단계적 접근 방식의 일반적인 장점인 유연성과 수정 편의성을 제공하는 것이다.

 

단계적 접근 방식을 사용할 때 고려해야 할 사항

a 종결점을 확인하라.

- 각 단계의 최댓값에 해당하는 경우를 처리했는지 확인해야 한다.

b. 순차 겁색법 대신 이진 검색법 사용을 고려해 보라.

- 학점 계산 예제에서 학점을 부여하는 루프는 등급의 최댓값이 있는 목록을 순차적으로 참조한다. 목록의 길이가 같다면 순차 검색으로 인한 비용이 매우 비쌀 것이다. 그런 경우에는 유사 이진 검색법을 사용할 수 있다. (유사 이진 검색법이라 불리는 이유는 찾고자 하는 값이 값이 아니라 범위이기 떄문)

c. 단계적 접근 방식 대신 인덱스 접근 방식 사용을 고려해 보라.

- 인덱스 접근 방식이 단계적 접근 방식의 좋은 대안이 될 수도 있다. 단계적 접근 방식에서는 검색해야 하는 부분이 늘어날 수 있으며, 실행 속도가 중요한 경우라면 인덱스 구조가 공간을 더 차지하더라도 좀 더 직접적인 접근 방식을 통해서 수행 속도를 빠르게 만들려고 할 것이다.