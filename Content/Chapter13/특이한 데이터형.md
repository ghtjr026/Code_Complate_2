13장 특이한 데이터형

o 구조체를 사용하면 프로그램이 덜 복잡하고 이해하기 쉬우며 유지보수에도 도움이 된다.

o 구조체를 사용할 때마다 구조체 대신 클래스도 고려해 본다.

o 포인터는 오류가 발생할 가능성이 높다. 접근 루틴이나 클래스, 방어적 프로그래밍 습관을 사용하여 보호한다.

o 전역 변수는 위험할 뿐만 아니라 더 좋은 다른 것으로 대체할 수 있으니 사용하지 않는다.

o 전역 변수를 꼭 사용해야 한다면 접근 루틴을 통해서 처리한다. 접근 루틴은 전역 변수가 제공하는 것 이상을 제공한다.

 

구조체

a. 데이터 관계를 이해하기 쉽게 하기 위해서 구조체를 사용하라.

- 구조체는 서로 관련돈 항목을 한 곳으로 모든다. 때때로 프로그램 파악 시 가장 난해한 부분이 데이터가 어디에서 어디로 흘러가는지 파악해야 할 때다.

b. 데이터 블록에 대한 작업을 단순화하기 위해서 구조체를 사용하라.

c. 매개변수 목록을 단순화하기 위해서 구조체를 사용하라.

d. 유지보수를 중리기 위해서 구조체를 사용하라.

 

포인터

a. 포인터 연산을 루틴이나 클래스에 고립시켜라.

- 프로그램의 여러 곳에서 링크드 리스트를 사용한다고 가정해 보자. 해당 리스트가 사용되는 곳에서 직접 포인터를 이용하여 다루는 대신 NextLink() 등 접근 루틴을 작성한다. 포인터에 접근하는 코드를 최소화함으로써 프로그램 전체에 영향을 미치고 찾는 데 아주 오랜 시간이 걸리는 부주의한 실수를 저지를 확률을 최소화할 수 있다.

b. 포인터를 선언과 동시에 정의하라.

c. 포인터를 할당된 곳과 같은 영역에서 삭제하라.

d. 포인터를 사용하기 전에 검사하라.

- 프로그램의 중요한 부분에서는 포인터를 사용하기 전에 해당 포인터가 가리키고 있는 메모리 위치가 유효한지 확인해야 한다.

e. 포인터가 참조하는 변수를 사용하기 전에 검사하라.

- 때때로 포인터가 가리키는 변수에 대해서 유효성 검사를 수행할 수 있다.

f. 손상된 메모리를 검사하는 인식표(dog-tag) 필드를 사용하라.

- “태그 필드” 또는 “인식표”는 오류 검사를 위한 목적으로 구조체에 추가하는 필드를 말한다. 변수를 할당할 때 바뀌면 안 되는 값을 태그 필드에 입력한다. 특히 메모리 삭제와 같이 구조체를 사용할 때 태그 필드의 값을 검사한다. 태그 필드가 예상했던 값이 아니라면 데이터가 손상된 것이다.

g. 명시적으로 중복 추가하라.

- 태그 필드 대신 사용할 수 있는 방법은 특정한 필드를 두 번 사용하는 것이다.

h. 여분의 포인터 변수를 사용하라.

- 절대로 포인터 변수를 아끼지 않는다. 변수는 하나 이상의 목적으로 사용되어서는 안 된다는 것이 핵심이다. 이는 포인터 변수의 경우에 특히 맞는 말이다. genericLink 변수가 왜 계속 사용되는지 또는 pointer->next->last->next가 무엇을 가리키는지 이해하지 않고는 링크드 리스트로 무엇을 하고 있는지 알아내기가 매우 어렵다.

i. 복잡한 포인터 표현식을 단순화하라.

j. 그림을 그려서 설명하라.

k. 링크드 리스트에 있는 포인터를 올바른 순서로 삭제하라.

- 동적으로 할당되는 링크드 리스트를 다룰 때 발생하는 일반적인 문제점은 리스트에 있는 첫 번째 포인터부터 해제하여 다음 포인터를 얻지 못하는 것이다. 이 문제를 피하기 위해서는 현재 요소를 해제하기 전에 다음 요소를 가리키는 포인터를 갖고 있어야 한다.

l. 임시 메모리를 할당하라.

m. 쓰레기를 확실하게 삭제하라.

n. 포인터를 삭제하거나 해제한 다음 널로 설정하라.

o. 변수를 삭제하기 전에 잘못된 포인터를 검사하라.

- 프로그램을 망치는 가장 좋은 방법의 하나는 이미 삭제되거나 해제된 포인터에 대해서 delete() 또는 free()를 사용하는 것이다. 해제된 포인터를 널로 설정하면 다시 사용하거나 삭제하려고 하기 전에 포인터가 널로 설정되어 있는지도 검사할 수 있다.

p. 포인터 할당을 추적하라.

- 할당한 포인터 목록을 유지한다. 이렇게 함으로써 어떤 포인터를 정리하기 전에 목록에 있는지 검사할 수 있다.

q. 포인터 문제를 피하기 위해 커버(Cover) 루틴을 작성하라.

- 포인터가 new되거나 delete 될 때마다 상당히 많은 코드를 작성해야 한다. (책에서 소개하는 예제가 링크드 리스트임) 이 절에서 소개한 몇몇 기법은 상반되거나 중복되는데, 그러한 전략을 사용하고 싶지는 않을 것이다. SAFE_NEW 루틴과 SAFE_DELETE 루틴 만들어서 사용할 수 있다. SAFE_NEW 루틴은 new를 하고 호출하고 새로운 포인터를 할당된 포인터 목록에 추가한 다음 호출한 루틴에 새롭게 할당된 포인터를 반환한다. SAFE_DELETE 루틴은 할당된 포인터 목록에 있는지 확인한 후 메모리에 쓰레기 값을 설정하고 포인터를 목록에서 지운 다음 delete를 호출하고 null로 설정하는 루틴이다.

포인터 삭제 코드를 래퍼에 작성한 c++ 예제

#define SAFE_DELETE( pointer) {

ASSERT( pointer != NULL, “Attempting to delete null pointer.” );

if ( IsPointerInList( pointer ) )

{

pointer->SetContentsToGarbage();

RemovePointerFromList( pointer );

delete pointer;

pointer =NULL;

}

else

{

ASSERT( FALSE, “Attempting to delete unallocated pointer.” );

}

}

 

C++ 포인터

a. 포인터와 참조의 차이점을 이해하라.

- C++에서는 포인터와 참조 모두 객체를 간접적으로 참조한다. 유일한 차이는 객체를 object->field와 object.field로 참조하는 외형상의 차이밖에 없어 보인다. 하지만 가장 중요한 차이점은 참조는 항상 객체를 참조해야 하는 반면 포인터는 null을 가리킬 수 있고, 참조는 참조하는 대상이 초기화가 된 후로 변경될 수 없다는 점이다.

b. “참조로 전달( Pass by Reference )” 매개변수에 포인터를 사용하고 “값으로 전달(Pass by Value)” 매개변수에 const 참조를 사용하라.

c. auto_ptrs를 사용하라.

- auto_ptr이 범위를 벗어날 때 자동으로 메모리를 삭제함으로써 일반적인 포인터와 관련된 많은 메모리 누수 문제를 피할 수 있다.

d. 스마트 포인터를 사용하라.

- 스마트 포인터는 일반 포인터 혹은 “벙어리(dumb)” 포인터를 대체한다. 스마트 포인터는 일반 포인터와 비슷하게 작동하지만, 자원 관리와 복사 작업, 할당 연산, 객체 생성과 소멸 기능을 제공한다.

 

C언어 포인터

a. 기본형 대신 명시적인 포인터형을 사용하라.

- C 언어에서는 변수의 형에 상관없이 char나 void 포인터를 사용할 수 있다. 가능한 한 명시적인 포인터형을 사용한다.

b. 형 변환을 피하라.

- 어떤 형으로 선언된 변수를 강제로 다른 형으로 선언된 변수의 공간에 집어넣지 말라는 뜻이다. 형 변환을 사용하면 컴파일러가 일치하지 않는 형을 검사할 수 없기 때문에 방어적 프로그래밍에 결함이 생긴다.

c. 매개변수를 전달하고자 할 때는 별표 규칙을 따르라.

- C언어에서는 할당문에서 해당 인자 앞에 별표(*)를 추가한 경우에만 루틴에 전달하는 매개변수를 원래의 루틴 쪽으로 전달할 수 있다. 많은 C 언어 개발자가 언제 루틴을 호출하는 쪽으로 값이 돌아가는지를 쉽게 결정하지 못한다.

d. 메모리 할당 시 변수의 크기를 결정하기 위해서 sizeof()를 사용하라.

 

전역 데이터

a. 전형적인 값의 보관

- 때때로 전체 프로그램에 영향을 끼치는 데이터가 필요할 때가 있다. 이는 대화식 모드인지 명령줄 모드인지, 또는 일반 모드인지 오류 복구 모드인지 등의 프로그램의 상태를 반영하는 변수일 것이다.

b. 이름 상수의 역할

c. 열거형 휸내 내기

- 열거형을 직접 지원하지 않는 파이썬 같은 언어에서는 열거형을 흉내 내기 위해서 전역 변수를 사용할 수 있다.

d. 매우 자주 사용되는 데이터의 사용을 능률화

- 때때로 모든 루틴의 매개변수 목록에 사용되어 지나치게 많이 참조되는 변수가 있을 수 있다. 그러한 변수를 모든 매개변수 목록에 포함시키는 대신 전역 변수르 만들 수 있다. 하지만 특정 변수를 모든 곳에서 접근하는 경우는 거의 드물다.

e. 뜨내기 데이터( tramp data ) 제거

- 때때로 다른 루틴이나 클래스로 전달하기 위한 목적으로 루틴이나 클래스에 데이터를 전달하는 경우가 있다. 예를 들면 각 루틴에서 사용하는 오류 처리 객체 같은 것이다. 일련의 호출 사이에 위치한 해당 루틴이 그 객체를 사용하지 않을 때 그 객체를 “뜨내기 데이터”라고 한다. 전역 변수를 사용하여 뜨내기 데이터를 제거할 수 있다.