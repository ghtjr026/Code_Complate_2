25장 코드 튜닝 전략

o 성능은 소프트웨어 품질 전체의 한 측면일 뿐이며 일반적으로 가장 중요한 항목도 아니다. 정밀하게 튜닝된 코드는 전체적인 성능의 한 측면일 뿐이며 일반적으로 그 효과가 눈에 보이지도 않는다. 프로그램 아키텍처, 상세 설계, 잘 구조와 알고리즘 선택이 일반적으로 코드의 효율성보다 프로그램의 수행 속도와 크기에 더 큰 영향을 미친다.

o 양적인 측정은 성능 최대화의 핵심이다. 그것은 성능 향상이 정말 중요한 영역을 찾는 데 필요하고 최적화가 소프트웨어의 성능을 향상시켰는지를 검증하는 데도 필요하다.

o 대부분의 프로그램은 작은 코드 영역에서 대부분의 시간을 보낸다. 코드를 측정하기 전까지는 그것이 어느 코드인지 알 수 없다.

o 코드 튜닝을 통해 원하는 만큼의 성능을 개선하기 위해서는 일반적으로 여러 번 반복해야 한다.

o 초기 코드 작성 시 성능 작업을 준비하는 가장 좋은 방법은 이해하고 수정하기 쉬운 분명한 코드를 작성하는 것이다.

 

성능과 코드 튜닝

고려해야 할 사항

a. 프로그램 요구사항

b. 프로그램 설계

- 주로 프로그램을 여러 개의 클래스로 나누는 방법에 해당하는 단일 프로그램 설계라는 주요 작업이 포함된다.

- 프로그램의 크기와 속도가 중요하다는 것을 알고 있다면 크기와 속도의 목표를 합리적으로 달성할 수 있게 아키텍처를 설계한다. 성능 중심적인 아키텍처를 설계한 다음 개별적인 서브시스템과 기능, 클래스에 대한 리소스 목표를 설정한다.

c. 클래스와 루틴 설계

- 성능을 위해 할 수 있는 활동은 데이터형과 알고리즘을 선택하는 것이다. 프로그램의 메모리 사용과 실행 속도에 영향을 미친다.

d. 운영체제 상호작용

- 프로그램이 외부 파일이나 동적 메모리, 출력 장치를 다룬다면 운영체와 상호작용할 것이고, 성능이 좋지 않다면 운영체제 루틴이 느리거나 비대하기 때문이다.

e. 코드 컴파일

- 좋은 컴파일러는 고급 프로그래밍 언어 코드를 최적화된 기계어 코드로 변환한다. 올바른 컴파일러를 선택하면 속도 최적화에 대해 더는 생각하지 않아도 된다.

f. 하드웨어

g. 코드 튜닝

- 코드가 더 효율적으로 작동하도록 정확하게 수정하는 방법이다. “튜닝”은 단일 클래스나 단일 루틴, 더 일반적으로 몇 줄의 코드에 영향을 미치는 작은 규모의 변경을 가리키며, 성능을 향상시키는 다른 고수준의 방법이나 큰 규모의 설계상 변경을 가리키는 것이 아니다.

 

코드 튜닝 소개

- 성능을 향상시키는 가장 효과적인 방법은 코드 튜닝이 아니며, 일반적으로 프로그램 아키텍처, 클래스 설계, 알고리즘 선택이 더 극적인 향상을 가져온다.

 

일반적인 오해를 포함한 코드 튜닝에 대한 이야기

a. 고급 언어에서 코드를 줄이면 결과적으로 기계어 코드의 속도나 크기를 향상시킨다 – 거짓

- 고급 언어에서의 코드의 수와 프로그램의 최종적인 크기와 속도에는 아무런 연관 관계가 없다.

b. 어떤 연산이 아마 다른 것보다 빠르거나 작을 것이다 – 거짓

- 어떤 기계에서 어떤 도구를 사용했을 때 참이었던 것이 다른 기계에서 다른 도구를 사용했을 때는 거짓일 수 있다. 코드를 튜닝할 때 암시적으로 컴파일러 상표와 컴파일러 버전, 라이브러리 버전 등을 변경할 때마다 최적화를 다시 측정해야 한다.

c. 코드를 작성하면서 최적화해야 한다 – 거짓

- 가장 간단한 프로그램을 구현함으로써 절약한 개발 시간이 작동하는 프로그램을 최적화하는 데 쓰인다면 그 프로그램은 무분별한 최적화 작업으로 개발된 프로그램보다 훨씬 더 빠르다.

d. 빠른 프로그램은 정확한 프로그램만큼 중요하다 – 거짓

 

느리고 비대한 부분

비효율성의 공통적인 원인

a. 입력/출력 연산

- 비효율성의 가장 중요한 원인 중 하나는 불필요한 입력/출력(IO)이다.

b. 페이징(paging)

- 운영체제가 메모리 페이지를 교체하게 하는 연산은 메모리 페이지 하나에서 작동하는 연산보다 훨씬 느리다.

페이지 오류를 많이 유발하는 초기화 루프를 자바로 작성한 예제

for ( column = 0; column < MAX_COLUMNS; column++ )

{

for ( row = 0; row < MAX_ROWS; row++ )

{

table[ row ][ column ] = BlankTableElement();

}

}

- 이 코드의 문제는 테이블에 있는 요소가 약 4000바이트 길이라는 점이다. 테이블에 행이 아주 많다면 프로그램이 다른 열에 접근할 때마다 운영체제가 메모리 페이지를 바꿔야 할 것이다.

페이지 오류가 적은 초기화 루프를 자바로 작성한 예제

for ( row = 0; row < MAX_ROWS; row++ )

{

for ( column = 0; column < MAX_COLUMNS; column++ )

{

table[ row ][ column ] = BlankTableElement();

}

}

- 이 코드는 행을 바꿀 때마다 페이지 오류가 발생하긴 하지만, MAX_ROWS * MAX_COLUMS번 대신 MAX_ROWS번만 열이 바뀐다.

c. 시스템 호출

- 시스템 루틴을 호출하면 context switching 이 발생한다. 시스템 루틴은 디스크, 키보드, 스크린, 기타 장치에 대한 입/출력 연산을 비롯해 메모리 관리 루틴, 특정한 유틸리티 루틴을 포함한다.

- 시스템 루틴의 비용이 비쌀 때 고려할 수 있는 대안 : 자신만의 서비스를 작성한다. or 시스템으로 가는 것을 피한다. or 시스템 루틴 호출을 더 빠르게 만들기 위해 시스템 벤더와 작업한다.

d. 인터프리트 언어

- 인터프리트 언어는 기계어 코드를 생성하고 실행하기 전에 각 프로그래밍 언어 명령을 처리해야 하기 때문에 상당한 성능 손해를 보는 경향이 있다.

e. 오류

- 오류에는 코드에 남겨진 디버깅 코드, 메모리 할당 해제 잊음, 부적절한 데이터베이스 테이블의 설계, 존재하지 않는 장치를 정해진 시간 동안 살펴보는 것 등이 있다.


코드 튜닝 단계 요약

a. 이해하고 변경하기 쉬운 잘 설계된 코드를 사용하여 소프트웨어를 개발한다.

b. 성능이 좋지 않다면

ㄱ. 나중에 “마지막으로 좋았던 상태”로 돌아올 수 있도록 작동하는 버전의 코드를 저장

ㄴ. 과열지점을 찾기 위해서 시스템을 측정

ㄷ. 성능이 취약한 것의 원인을 판단한다. 코드 튜닝이 적절하지 않다면 (a)단계로 돌아간다.

ㄹ. (ㄷ) 단계에서 규명된 병목을 튜닝한다.

ㅁ. 한 번에 하나씩 성능을 측정한다.

ㅂ. 코드의 성능이 향상되지 않았다면 (ㄱ)단계에서 저장했던 코드로 돌아간다.

- 전형적으로 튜닝 시도의 절반 이상은 성능에 큰 영향을 미치지 못하거나 오히려 성능을 떨어뜨릴 것이다.

c. (b) 단계를 반복한다.