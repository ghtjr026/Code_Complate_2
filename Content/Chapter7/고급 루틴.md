7장 고급 루틴

o 루틴을 작성하는 가장 중요한 이유는 사람이 관리하고 이해하기에 더 쉬운 코드를 작성하기 위한 것이며 그 밖의 이유도 다양하다. 단순히 공간을 줄이겠다는 것은 고려할 사항이 아니다. 이해하기 쉽고 믿을 수 있고 변경하기 편한 코드를 작성하는 데 그 목표가 있다.

o 때로는 별도의 루틴을 작성함으로써 얻는 이득이 크지 않을 수 있다.

o 루틴을 다양한 형태의 응집성에 따라 분류할 수 있지만, 가장 좋은 기능적 응집성을 갖도록 루틴을 분류하는 것이 가장 좋다.

o 루틴의 품질을 이야기할 때는 이름도 고려한다. 이름이 별로이면서 정확하다면 루틴은 잘못 설계된 것이다. 이름도 별로고 정확하지도 않으면 이름으로 프로그램이 무엇을 하는지 알 수 없다. 어느 경우든지 이름이 좋지 않으면 프로그램을 변경해야 한다.

o 함수는 그것의 주된 목적이 함수의 이름에 묘사된 특정한 값을 리턴할 때만 사용되어야 한다.

o 주의 깊은 개발자는 매크로를 주의 깊게 사용하며 최후의 수단으로만 사용한다.

 

루틴을 작성해야 하는 이유

a. 복잡성을 줄인다.

- 프로그램의 복잡성을 줄이는 것이 루틴을 작성하는 가자 중요한 목적이다.

b. 이해하기 쉬운 중간 단계의 추상화를 도입한다.

- 코드의 일부를 이해하기 쉬운 이름의 다른 루틴으로 작성하는 것이 좋다. 예를 들어 긴 루틴을 함수화하는 것이라고 볼 수 있다.

c. 충복 코드를 피한다.

d. 서브클래싱을 지원한다.

- 길고 구조화가 덜 된 루틴보다 길이도 짧고 구조적으로 완성도 높은 루틴을 오버라이드하면 변경할 내용이 많지 않다. 또한 오버라이드가 가능한 루틴을 간단하게 유지하면 서브클래스 구현에서 오류가 발생할 확률도 줄어들 것이다.

e. 코드의 실행 숭서를 감춘다.

- 이벤트가 처리되는 순서를 숨기는 것이 좋다. 가령 프로그램 사용자로부터 정보를 입력받은 후 추가 정보를 파일에서 가져와야 한다면 두 가지 작업을 별도의 루틴으로 작성할 수 있다.

f. 포인터 연산을 감춘다.

- 포인터 연산은 처리하기 까다로워 오류가 발생할 가능성이 높다. 포인터 연산 작업을 루틴에 구현함으로써 복잡한 포인터 연산에 대한 고민 없이 개발에만 집중할 수 있다. 또한 포인터 연산을 한 곳에서 처리함으로써 더욱 안전한 코드를 개발할 수 있다. 이후에 포인터보다 더 나은 새로운 데이터형을 사용하고 싶을 때도 루틴을 변경함으로써 모든 코드에 적용할 수 있다.

g. 이식성을 높인다.

- 루틴을 사용하면 미래에 이식이 가능한 기능과 그렇지 않은 기능을 구분할 수 있다. 이식이 불가능한 기능에는 표준이 아닌 언어의 기능, 하드웨어 의존성, 운영체제 의존성 등이 포함된다.

h. 복잡한 불린 테스트를 단순화한다.

- 프로그램의 흐름을 이해하기 위해서 복잡한 불린(참/거짓) 테스트를 상세하게 이해할 필요는 없다. 그러한 테스트를 함수로 작성하면 코드를 좀 더 쉽게 이해할 수 있다.

I. 성능을 개선한다.

 

좋은 루틴 이름

a. 루틴이 하는 모든 것을 표현하라.

b. 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 마라.

c. 루틴 이름을 숫자만으로 구분하지 마라.

d. 루틴 이름의 길이에 신경 쓰지 마라.

e. 함수의 이름을 지을 때는 리턴 값에 관해서 설명하라.

f. 프로시저의 이름을 지을 때 확실한 의미가 있는 동사를 객체 이름과 함께 사용하라.

- 기능적 응집성을 갖는 프로시저는 일반적으로 하나의 객체에 대해서 한 가지 연산을 수행한다. 프로시저의 이름은 프로시저가 무슨 일을 하는지 반영해야 하기 때문에 객체에 대한 연산은 동사에 객체 이름을 붙여 쓴 형태의 이름을 갖는다. ( e.g. PrintDocument(), CheckOrderInfo() 등 )

g. 반의어를 정확하게 사용하라.

h. 공통적인 연산을 위한 규약을 만들어라.

- 시스템 환경에 따라 각 연산을 명확하게 구분하는 일은 매우 중요하다.