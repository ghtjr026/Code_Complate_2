8장 방어적 프로그래밍

o 제품 코드는 “쓰레기를 입력하면 쓰레기가 나온다”라는 말보다 정교한 방법으로 오류를 처리해야 한다.

o 방어적 프로그래밍 기법은 오류를 찾거나 수정하기 쉽고 제품 코드에 손상을 덜 입힌다.

o 어설션은 특히 큰 시스템, 신뢰성이 높은 시스템, 빠르게 코드가 변경되는 시스템에서 오류를 초기에 발견하는 데 도움이 된다.

o 잘못된 입력 데이터를 처리하는 방법에 대한 결정은 오류 처리와 고수준 설계에서 핵심적인 결정 사항이다.

o 예외는 코드의 정상적인 흐름과 다른 차원에서 오류를 처리하는 방법을 제공한다. 예외는 조심스럽게 사용하면 개발자에게 유용한 도구이며 다른 오류 처리 기법과 견주어가며 사용해야 한다.

o 제품 시스템에 적용되는 제약 사항이 반드시 개발 버전에 적용될 필요는 없다. 그러한 사항을 자신에게 유리하게 사용할 수 있으며 오류를 빠르게 검출하는 데 도움이 되는 코드를 개발 버전에 추가할 수 있다.

 

어설션 ( Assertion )

- 대개 루틴이나 매크로 실행 시 프로그램이 스스로 검사할 수 있도록 사용하는 코드다. 어설션이 참 ( True ) 이면 모든 것이 예상대로 작동하고 있다는 것을 의미한다. 반대로 거짓 ( False ) 의 경우는 코드에서 예상치 못한 오류가 감지되었다는 뜻이다.

어설션은 다음과 같은 가정을 검사하는 데 사용될 수 있다.

a. 입력(또는 출력) 매개변수의 값이 예상된 범위 안에 들어가는지

b. 파일이나 스트림이 루틴이 시작할 때(또는 끝날 때) 열려있는지(또는 닫혀있는지)

c. 파일이나 스트림이 루틴이 시작할 때(또는 끝날 때) 시작(또는 끝)에 있는지

d. 파일이나 스트림이 읽기 전용이나 쓰기 전용, 읽기/쓰기로 열려있는지

e. 입력만 가능한 변수의 값이 루틴에 의해서 변경되지 않는지

f. 포인터가 Null이 아닌지

g. 루틴에 전달되는 배열이나 다른 컨테이너가 적어도 X개의 데이터 요소를 포함할 수 있는지

h. 테이블이 실제 값을 포함할 수 있도록 초기화되었는지

I. 컨테이너가 루틴이 시작할 때(또는 끝날 때 비어(또는 채워)있는지

j. 매우 최적화되어 있고 이해하기 어려운 루틴의 결과가 수행 속도는 느리지만 이해하기 쉬운 루틴의 결과와 일치하는지

 

어설션 사용 지침

a. 발생이 예상되는 상황에 대해서는 오류 처리 코드를 사용하되, 절대로 발생해서는 안 되는 조건에 대해서는 어설션을 사용하라

b. 실행할 가능성이 있는 코드를 어설션 내에 입력하지 않는다.

- 실행문은 별도의 줄에 입력하고 그 결과를 상태 변수에 할당한 다음, 상태 변수를 테스트하라.

c. 선행 조건과 후행 조건을 문서화하고 검증하는 데 어설션을 사용하라. (※ 선행 조건 : 루틴이나 클래스에서 다른 루틴을 호출하거나 객체를 생성하기 전에 반드시 참이어야 하는 특성, 후행 조건 : 루틴이나 클래스를 호출하고 난 후에 반드시 참이어야 하는 조건이다.)

- 어설션은 선행 조건과 후행 조건을 설명하기에 매우 유용하다. 주석으로 선행 조건과 후행 조건을 설명할 수도 있지만, 주석과 달리 어설션은 선행 조건과 후행 조건이 참인지를 동적으로 검사할 수 있다.

d. 매우 견고한 코드를 작성하기 위해서는 어설션은 무조건 포함하고 그 다음에 오류를 처리하라.

 

오류 처리 기법

- 발생할 것이 예상되는 오류를 처리하는 방법이다.

 

a. 중립적인 값을 반환한다.

- 잘못된 데이터에 대한 가장 좋은 대응은 작업을 계속 수행하더라도 아무런 문제가 없다고 알려진 값을 반환하는 방법이다. 수식이라면 0을 반환하고 문자열 연산에서는 빈 문자열을 반환하고 포인터 연산은 빈 포인터를 반환한다.

b. 다음에 오는 유효한 데이터로 대체한다.

- 데이터 스트림을 처리할 때 어떤 환경에서는 간단하게 다음에 오는 유효한 데이터를 반환해도 되는 경우가 있다. 데이터베이스에서 데이터를 읽고 있을 때 깨진 레코드를 만나게 된다면 아마도 유효한 레코드를 찾을 때까지 계속해서 읽을 것이다.

c. 이전과 같은 값을 반환한다.

- 온도를 읽는 소프트웨어가 온도를 한 번 읽지 못한다면 아마도 마지막에 읽었던 값과 같은 값을 반환할 것이다. 응용 프로그램에 따라 다르겠지만, 온도가 1100분의 1초만에 그렇게 많이 변하지는 않을 것이다.

d. 가장 가까운 유효한 값으로 대체한다.

- 어떤 경우에는 앞의 Velocity 예제에서와같이 가장 가까운 유효한 값을 반환하는 방법을 선택할 것이다. 이는 종종 눈금을 사용하는 도구에서 값을 얻어올 때 처리할 수 있는 합리적인 접근 방법이다.

e. 경고 메시지를 파일에 기록한다.

- 잘못된 데이터를 감지하면 경고 메시지를 파일에 기록한 다음 계속해서 실행하는 방법을 선택할 수도 있다. 이 접근 방법은 가장 가까운 유효한 값으로 대체하거나 다음에 오는 유효한 값으로 대체하는 것과 다른 기법과 함께 사용될 수 있다.

f. 오류 코드를 반환한다.

- 시스템의 특정한 부분만 오류를 처리하도록 할 수 있다. 다른 부분은 오류를 처리하지 않고 오류가 감지되었다는 것을 보고하고 호출 계층의 위에 있는 다른 루틴이 오류를 처리할 것이라고 믿는 것이다.

- 상태 변수에 값을 설정한다.

- 함수의 리턴 값으로 상태 값을 반환한다.

- 프로그래밍 언어에서 기본 제공하는 예외 매커니즘을 사용하여 예외를 던진다.

g. 오류 처리 루틴이나 객체를 호출한다.

- 또 다른 접근 방법은 오류 처리를 전역적인 오류 처리 루틴이나 오류 처리 객체에 집중시키는 것이다. 이러한 접근 방법의 장점은 오류를 처리해야 하는 부분이 집중될 수 있어서 디버깅이 쉬워진다는 점이다.

h. 오류가 발생한 곳에서 오류 메시지를 출력한다.

- 이 접근 방법은 오류 처리의 오버헤드를 최소화한다. 하지만 사용자 인터페이스 메시지가 전체 응용 프로그램에 영향을 미치게 되어 일관성 있는 사용자 인터페이스를 작성해야 할 때나 UI와 시스템의 나머지 부분을 분명하게 구분하려고 할 때, 소프트웨어를 다른 언어로 지역화하려고 할 때 어려움을 겪을 수 있다.

i. 상황에 따라 가장 잘 작동하는 방법으로 오류를 처리한다.

- 어떤 설계는 모든 오류를 상황에 맞게 처리한다. 어떤 오류 처리 방법을 사용할 것인지에 대한 결정이 오류가 발생하는 부분을 설계하고 구현하는 개발자에게 달려있다.

j. 종료한다.

- 어떤 시스템은 오류를 발견할 때마다 종료된다. 이 접근 방법은 안전성이 매우 중요한 으용 프로그램에서 유용하다. 예를 들어 암 환자를 치료하기 위한 방사선 치료기구를 제어하는 소프트웨어가 방사선량에 대한 잘못된 입력 데이터를 받는다면 오류 처리에 대한 가장 좋은 처리 방법은 종료하는 것이다.

 

예외

a. 예외를 사용해 무시되어서는 안 되는 오류를 프로그램의 다른 부분에 알린다.

- 예외의 가장 큰 이득은 절대로 무시하지 못할 방법으로 오류가 발생한 상황을 알릴 수 있는 능력이다.

b. 정말로 예외적인 조건인 경우에만 예외를 던져라.

- 예외는 정말로 예외적인 경우 즉, 다른 코드 작성 습관으로는 해결할 수 없는 경우에만 사용해야 한다. 예외는 어셜션처럼 자주 발생하지 않는 경우뿐만 아니라 절대로 일어나서는 안 되는 경우에 사용된다. 예외를 사용할 때는 예상치 못한 조건을 처리하는 강력한 방법과 복잡성 증가 사이에서 균형을 잘 맞춰야 한다. 예외는 루틴을 호출하는 코드가 호출된 코드의 내부에서 어떤 예외를 던질 것인지를 알아야 하므로 캡슐화를 약화한다.

c. 책임을 전가하기 위해서 예외를 사용하지 않는다.

- 오류를 발생한 코드에서 처리할 수 있다면 직접 처리하는 게 좋다. 오류를 처리할 수 있는데도 처리되지 않은 예외를 던지지 않도록 한다.

d. 생성자와 소멸자에서 예외를 잡을 수 없다면 생성자와 소멸자에서 예외를 던지지 않는다.

- 예외를 처리하는 방법을 정할 때 예외를 생성자와 소멸자에서 발생시킬 수 있다고 가정하면 코드가 매우 복잡해진다. 예를 들면 C++에서 소멸자는 객체가 완전히 생성되기 전에는 호출되지 않는다 이 말은 생성자에서 예외를 던진다면 소멸자가 호출되지 않기 때문에 리소스 누수가 있을 수 있다는 것을 의미한다.

e. 올바른 추상화 수준에서 오류를 던진다.

- 루틴은 루틴의 인터페이스에서 일관된 추상화를 제공해야 한다. 클래스도 마찬가지다. 루틴에서 발생하는 예외는 다른 데이터형과 마찬가지로 루틴 인터페이스의 일부다.

f. 예외를 발생시킨 모든 정보를 예외 메시지에 포함한다.

- 모든 예외는 코드가 예외를 던질 때 감지된 특정한 환경에서 발생한다. 이러한 정보는 예외 메시지를 읽는 사람에게 매우 유용하다. 메시지에는 예외가 발생한 이유를 이해하는 데 필요한 정보를 포함하도록 한다. 배열 인덱스 오류 때문에 예외가 던져졌다면 예외 메시지에 배열 인덱스의 최댓값과 최솟값, 잘못된 인덱스의 값이 포함되도록 한다.

g. 라이브러리 코드가 던지는 예외를 파악한다.

- 루틴이나 클래스가 던지는 예외를 정의할 필요가 없는 프로그래밍 언어로 개발하고 있다면 사용하는 라이브러리 코드가 던지는 예외가 무엇인지를 알아야 한다. 라이브러리 코드에서 발생한 예외를 잡지 못하면 프로그램에 충돌이 발생할 것이다. 라이브러리 코드가 자신이 던지는 예외를 기록하지 않았다면 라이브러리를 사용해 보고 예외를 잡기 위한 프로토타입 코드를 작성한다.

h. 중앙 집중화된 예외 보고 시스템 구축을 고려한다.

- 예외 처리에서 일관성을 보장하는 한 가지 접근 방법은 중앙 집중화된 예외 보고 시스템을 사용하는 것이다. 중앙 집중된 예외 보고 시스템은 예외의 종류와 예외 처리 방법, 예외 메시지의 형식화에 대한 내용을 저장하는 중앙 보관 창고를 제공한다.

i. 프로젝트의 예외 사용을 규격화한다.

- 예외 처리를 쉽게 이해할 수 있도록 다양한 방법으로 예외의 사용을 규격화할 수 있다.

- C++와 같이 다양한 객체, 데이터, 포인터를 던질 수 있는 프로그래밍 언어를 사용하고 있다면 구체적으로 무엇을 던질 것인지에 대해서 규격을 정한다. 다른 언어와의 호환성을 위해서 Exception 기본 클래스로부터 파생된 객체만 덕지는 것을 고려해본다.

- 프로젝트에서 발생시키는 모든 예외에 대해서 기본 클래스로 사용할 수 있는 프로젝트에 특화된 예외 클래스를 작성하는 것을 고려해 본다. 기록과 오류 보고 등을 집중시키고 규격화 할 수 있다.

- 오류를 처리하기 위해서 어떤 코드가 throw-catch 문법을 사용할 수 있는지에 대한 구체적인 상황을 정의한다.

- 어떤 코드가 처리되지 않는 예외를 던질 수 있는지에 대한 구체적인 상황을 정의한다.

- 중앙 집중화된 예외 보고자가 사용될 것인지 결정한다.

- 예외가 생성자와 소멸자에서 허용되는지 정의한다.

j. 예외의 대안을 고려해 본다.