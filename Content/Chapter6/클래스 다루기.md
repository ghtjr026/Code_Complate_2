6장 클래스 다루기

o 클래스의 인터페이스는 일관성 있는 추상화를 제공해야 한다 이 규칙을 어기면 많은 문제가 발생한다.

o 클래스의 인터페이스는 시스템 인터페이스나 설계 결정, 구현 세부 사항을 숨겨야 한다.

o “is a”관계를 모델링하고 있지 않다면 상속보다 포함을 선택하는 것이 좋다.

o 상속은 유용한 도구지만, 복잡성을 증가시키며 그로 인해 복잡성 관리가 어려워진다.

o 클래스는 복잡성을 관라하기 위해서 사용할 수 있는 기본적인 도구다. 복잡성을 관리할 수 있도록 설계에 많은 주의를 기울여라.

 

추상 데이터형( Abstract Data Type, ADT )은 데이터와 데이터를 처리하는 연산의 집합이다. 연산은 프로그램의 나머지 부분에 데이터가 무엇인지를 설명해주는 역할과 나머지 프로그램에서 그 데이터를 변경할 수 있게 해주는 역할을 한다.

ADT를 사용할 때 좋은 점

a. 구현 세부 사항을 감출 수 있다.

- ADT를 통해 구현 세부사항을 감추지 않았다면 같은 루틴을 사용하는 모든 곳에서 코드를 변경해야 한다. 또한, 세부 구현을 감추면 해당 정보를 메모리가 아닌 외부 저장소에 저장할 때나 반복적으로 사용하는 처리 루틴을 다른 프로그래밍 언어로 구현하고자 할 때도 다른 부분을 변경할 필요가 없다.

b. 변경이 전체에 영향을 미치지 않는다.

c. 인터페이스가 더 많은 정보를 제공하도록 만들 수 있다.

- 유사한 모든 연산을 하나의 ADT에 모아 놓으면 전체 인터페이스를 일괄적으로 포인트나 픽셀 형태로 정의하거나 둘을 분명하게 구별하여 혼란을 피할 수 있다. ( ※ 포인트나 픽셀의 내용은 책의 ‘ADT가 필요한 예’에서 보여진 것 )

d. 성능을 향상시키기 쉽다. -

e. 프로그램이 명백하게 정확해진다.

- 연산을 바로 사용하는 것보다 ( 폰트의 굵기 세팅하는 코드 : Font.attribute = Font.attribute | 0x02 ) 함수를 호출 ( Font.SetBoldOn() ) 하여 확인 작업을 하도록 고친다.

f. 프로그램의 가독성이 높아진다.

g. 전체 프로그램에 데이터를 넘길 필요가 없다.

- ADT를 사용하면 데이터를 프로그램 전체에 전달할 필요가 없으며 전역 변수로 변환할 필요도 없다. ADT는 데이터를 보관할 수 있는 구조로 되어 있으며, 그 데이터는 ADT의 일부인 루틴에 의해서만 직접 접근할 수 있다.

h. 저수준 구현 구조체 대신 현실 세계의 개체를 다룰 수 있다.

- ADT를 사용한 것과 사용하지 않은 것의 차이점은 데이터 처리를 루틴의 집합으로 제한했다는 것이다. 데이터 처리에 있어서 더 나은 추상화 수준을 제공하고 데이터 변경 시 보호막이 생긴다.

 

좋은 추상화

a. 클래스 인터페이스가 일관된 추상화 수준을 갖도록 한다.

e.g. 추상화 수준이 뒤섞인 클래스 인터페이스 c++로 작성한 예제

cass EmployeeCensus : public ListContainer {

public:

...

//공개 루틴

void AddEmployee ( Employee employee );

vdoi RemoveEmployee ( Employee employee );

Employee NextItemInList();

Employee FirstItem();

Employee LastItem();

...

private:

...

};

- 두 개의 ADT, Employee와 ListContainer를 표현하고 있다. 추상화 수준이 다른 상황은 컨테이너 클래스나 다른 라이브러리 클래스를 내부적으로 사용했지만, 라이브러리 클래스가 사용됐다는 사실을 감추지 않은 경우에 발생한다.

e.g. 추상화 수준이 일관성 있는 클래스 인터페이스를 C++로 작성한 예제

class EmployeeCensus {

public:

...

//공개 루틴

void AddEmployee ( Employee employee );

void RemoveEmployee ( Employee employee );

Employee NextEmployee();

Employee FirstEmployee();

Employee LastEmployee();

...

private:

ListContainer m_EmployeeList;

...

};

b. 클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다.

c. 서로 반대되는 기능을 갖는 서비스 쌍을 제공하라.

- 대부분의 연산은 유사하거나 같거나 정반대의 연산을 갖고 있다. 불을 켜는 연산이 있다면 끄는 연산도 필요할 것이고, 리스트에 항목을 추가하는 연산이 있다면 리스트에서 항목을 제거하는 연산이 필요할 것이다. 클래스를 설계할 때 각 공개 루틴에 반대되는 기능이 필요한지 확인하고 불필요하다면 만들어서는 안되지만, 필요하다면 만들어야하므로 필요성을 확인해야 한다.

d. 관련이 없는 정보를 다른 클래스로 옮겨라.

- 예를 들면 한 클래스 내에서 루틴의 반이 일부 데이터를 다루고 나머지 루틴이 나머지 데이터를 처리하는 경우가 있다. 이러한 경우 물리적으로는 하나의 클래스이긴 하지만, 실제로는 두 개의 서로 다른 클래스나 마찬가지다. 둘로 나누어 사용하자.

e. 가능하면 인터페이스를 의미론적이기보다는 프로그래밍적으로 만들어라.

- 프로그래밍적인 부분은 인터페이스에서 컴파일러로 강제화할 수 있는 데이터형이나 특성으로 구성된다. 의미론적인 부분은 인터페이스가 어떻게 사용될 것인지에 대한 가정으로 구성된다. 이 부분은 컴파일러에 의해서 강제화할 수 없는 부분이다. 예로 ”RoutineA는 반드시 RoutineB보다 먼저 호출되어야 한다.“와 같은 고려사항을 포함한다.

f. 코드 변경 시 인터페이스의 추상화가 망가지지 않도록 주의한다.

g. 인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 말라.

h. 추상화와 응집도를 함께 고려하라.

 

좋은 캡슐화

a. 클래스와 멤버의 접근성을 최소화하라.

- 어떤 루틴을 public으로 선언해야 할지, private 또는 protected로 선언해야 할지 고민하고 있다면 가능한 한 엄격한 프라이버시 수준을 선택하는 것은 좋은 지침일 수 있다. 하지만 더 중요한 지침은 ”어떻게 해야 인터페이스 추상화의 무결성을 최상으로 유지할 수 있는가?“다.

b. 멤버 데이터를 public으로 노출하지 말라.

- 멤버 데이터 노출은 캡슐화에 위반되고 추상화를 어렵게 만든다.

c. 내부 구현 세부 사항을 클래스의 인터페이스에 입력하지 말라.

- 진정한 캡슐화는 개발자가 구현 세부 사항을 전혀 볼 수 없다.

e.g. 클래스의 구현 세부 사항을 노출하고 있는 c++ 예제

class Employee {

public:

...

Employee(

FullName name,

String address,

String workPhone,

String homePhone,

TaxId taxIdNumber,

JobClassification jobClass

);

...

FullName GetName() const;

String GetAddress() const;

private:

String m_Name;

String m_Address;

int m_jobClass;

...

};

- 이 경우 클라이언트는 JobClassification 타입을 사용해야 하지만 헤더 파일을 보면 jobClass가 정수형으로 저장되고 있다는 구현 세부 사항을 확인할 수 있다.

e.g. 클래스의 구현 세부 사항을 감추고 있는 c++ 예제

class Employee {

public:

...

Employee (... );

...

FullName GetName() const;

String GetAddress() const;

...

private:

EmployeeImplementation *m_implementation;

};

- 이제 EmployeeImplementation 클래스에 구현 세부 사항을 입력할 수 있다.

d. 클래스의 사용자를 가정하지 말라.

e. 프렌트(friend) 클래스를 피하라.

f. 어떤 루틴이 공개 루틴만 사용한다고 해서 public 인터페이스에 두지 말라.

g. 코드를 작성할 때의 편의성보다 가족성이 높은 코드를 작성하라.

h. 캡슐화의 의미론적인 위반을 각별히 주의하라.

i. 지나치게 밀접한 결합을 주의하라.

- 결합은 두 클래스 사이의 연결이 얼마나 밀접한지를 가리킨다. 결합은 느슨할수록 좋다.

- 클래스와 멤버의 접근성을 최소화하라.

- 프렌드 클래스는 너무 밀접하게 결합되기 때문에 피하라.

- 파생 클래스와 기본 클래스가 느슨하게 연결되도록 기본 클래스의 데이터를 protected가 아닌 private으로 선언하라.

- 클래스의 공개 인터페이스에서 멤버 데이터를 노출하지 말라.

- 의미론적인 캡슐화를 유지하라.