23장 디버깅

o 디버깅은 소프트웨어 개발의 성패를 좌우한다. 가장 좋은 접근 방법은 이 책에서 소개하는 다른 기법을 사용해 결함을 처음부터 피하는 것이다. 그래도 디버깅 기술을 향상하는 데 시간을 투자할 가치가 있다. 왜냐하면 디버깅을 잘하는 사람과 못하는 사람 사이의 수해 능력이 적어도 10배 정도 차이가 나기 때문이다.

o 오류를 찾고 수정하는 데 체계적으로 접근하는 것은 성공에 매우 중요하다. 각 테스트가 한 걸음 더 나아갈 수 있도록 디버깅에 초점을 맞춘다. 과학적인 디버깅 방법을 사용하라.

o 문제를 수정하기 전에 문제의 원인을 이해하라. 오류의 원인을 임의로 추측하고 수정하면 프로그램은 수정하기 전보다 더 나쁜 상태가 될 것이다.

o 컴파일러의 경고를 가장 까다로운 수준으로 설정하고 컴파일러가 보고하는 오류를 수정하라. 분명한 오류를 무시하면 수정하기가 어려워진다.

o 디버깅 도구는 소프트웨어 개발에 도움이 되는 강력한 도구다. 그러한 도구를 찾아서 사용하는 동시에 자신의 두뇌를 사용하는 것도 잊지 말라.

 

디버깅

- 오류의 근본적인 원인을 규명하여 수정하는 과정이다. 프로그래밍 중에서 가장 어려운 부분이며, 어떤 프로젝트에서는 디버깅이 전체 개발 시간의 50%를 차지한다.

 

기회로서의 결함

a. 개발 중인 프로그램에 관해 배울 수 있다.

b. 자신이 저지른 실수에 관해 배울 수 있다.

c. 자신의 코드를 읽어야 하는 사람의 관점으로부터 코드의 품질에 관해 배울 수 있다.

d. 문제를 해결하는 방법을 배울 수 있다.

e. 결함을 수정하는 방법을 배울 수 있다.

 

과학적인 디버깅 방법

단계

반복적인 실험을 통해 데이터를 수집

관련 자료를 설명하기 위한 가설을 세움

가설을 증명하거나 반증하기 위한 실험을 구상

가설을 증명하거나 반증

필요한 만큼 반복.

 

결함을 찾는 효과적인 접근 방법

오류 재현

오류( 결점 )의 원인을 찾음

a. 결함을 만들어내는 데이터 수집

b. 수집된 데이터 분석 및 결함에 대한 가설 세움

c. 프로그램을 테스트하거나 코드를 살펴봄으로써 가설을 증명하거나 반증할 방법 결정

d. c 에서 규명한 절차를 사용하여 가설을 증명하거나 반증

3. 결함을 수정

4. 수정 내용 테스트

5. 유사한 오류 찾기

 

결함을 찾는 데 도움이 되는 팁

a. 가설을 세우기 위해서 사용할 수 있는 모든 데이터를 사용하라.

- 결함의 원인에 대한 가설을 세울 떄 가설에서 가능한 한 많은 데이터를 설명한다.

b. 오류를 만드는 테스트 케이스를 개선하라.

- 오류의 원인을 찾을 수 없다면 기존에 가지고 있던 테스트 케이스를 개선해 본다. 하나의 요인을 가정했던 것보다 더 다양하게 바꿔볼 수 있으며 여러 요인 중 하나에 집중하는 것이 중대한 돌파구를 제공할 수도 있다.

c. 단위 테스트에서 코드를 다루어라

d. 도구를 사용하라.

e. 여러 가지 방법으로 오류를 발생시켜라.

- 때로는 오류를 만드는 경우와 유사하지만 정확하게 같지는 않은 경우를 시도해 보는 것이 도움이 된다. 한 지점에서 수정하고 또 다른 지점에서 수정하면 결함이 어디 있는지 더 정확하게 결정할 수 있다.

f. 더 많은 가설을 세우기 위해서 더 많은 데이터를 만들어라

- 이미 오류가 있는지 알고 있는 테스트 케이스와 다른 테스트 케이스를 선택한다. 그 테스트를 실행해 더 많은 데이터를 만들고 그렇게 얻은 새 데이터를 이용해 가능한 가설을 추가한다.

g. 부정적 테스트의 결과를 사용하라.

- 가설을 세우고 그 가설을 증명하기 위해서 테스트 케이스를 사용한다고 가정해 보자. 그리고 그 테스트 케이스가 가설을 부정하여 여전히 오류의 원인을 모른다고 가정해 보자. 분명히 이전에는 알지 못했던 것을 알게 된다. 즉, 결함이 생각했던 영역에 있지 않다는 ᄉᆞ실을 알게 된다. 그러한 방법으로 찾아야 할 부분과 가능한 가설의 폭을 좁힌다.

h. 가능한 가설에 대해서 브레인스토밍하라.

- 첫 번째 가설에 자신을 국한하지 말고 여러 가지 가설을 떠올려 본다.

i. 시도해 볼 목록을 만들어라

j. 의심스러운 코드 영역을 좁혀라

- 의심스러운 코드의 영역을 좁히기 위한 더욱 강력한 기법이 필요하다면 체계적으로 프로그램을 부분적으로 제거하면서 오류가 계속해서 발생하는지 살펴본다. 오류가 발생하지 않는다면 제거한 부분에 오류가 있다는 것을 알 수 있다.

k. 이전에 결함이 있었던 클래스와 루틴을 의심하라.

l. 최근에 변경한 코드를 검사하라.

n. 의심스러운 코드 영역을 확장하라.

- “결함이 이 부분에 반드시 존재한다.”라고 확신하지 마라.

m. 점진적으로 통합하라.

- 시스템에 한 번에 한 부분만 추가한다면 디버깅이 쉬워진다.

o. 일반적인 결함을 검사한다.

- 가능한 결함을 생각하는 데 도움을 얻기 위해 코드 품질 체크리스트를 사용한다.

p. 프로그램에 대해 다른 사람과 이야기를 나누어라

q. 문제로부터 떨어져 휴식을 취하라.

 

결함 수정

a. 수정하기 전에 문제를 이해하라

b. 문제만 이해하지 말고 프로그램을 이해하라.

c. 결함 분석을 확인하라.

- 결함을 수정하기 전에 문제를 정확하게 분석한다.

d. 원본 소스 코드를 저장하라.

e. 증상이 아닌 문제를 해결하라.

- 증상도 해결해야 하지만 문제를 임시로 코드로 막는 것보다는 근본적인 문제를 해결하는 데 집중해야 한다.

수정해야 하는 코드를 자바로 작성한 예제

for ( claimNumber = 0; claimNumber < numClaims[ clinet ]; claimNumber++ )

{

sum[ client ] =sum[ client ] + clainAmount[ claimNumber ];

}

- client가 45일 때 sum의 값이 3.45 차이로 틀렸다고 가정한다.

문제를 해결했지만, 코드는 더 엉망이 된 예제

for ( claimNumber = 0; claimNumber < numClaims[ clinet ]; claimNumber++ )

{

sum[ client ] =sum[ client ] + clainAmount[ claimNumber ];

}

if ( client == 45 )

{

sum [ 45 ] = sum[ 45 ] + 3.45;

}

- 이제 client가 37이고 고객의 청구 번호가 0이지만, 합은 0이 아니라고 가정해보자

문제는 해결했지만, 코드는 더 엉망이 된 예제

for ( claimNumber = 0; claimNumber < numClaims[ clinet ]; claimNumber++ )

{

sum[ client ] =sum[ client ] + clainAmount[ claimNumber ];

}

if ( client == 45 )

{

sum [ 45 ] = sum[ 45 ] + 3.45;

}

else if ( ( client == 37 ) && ( numClaims[ clinet ] == 0 ) )

{

sum[ 37 ] = 0.0;

}

f. 타당한 이유가 있을 때만 코드를 변경하라.

- 증상 수정과 관련하여 작동하는 것처럼 보일 때까지 임의로 코드를 변경하는 기법이 있다. 이때 사용되는 전형적인 추론은 다음과 같다. “이 반복문은 결함을 포함하고 있는 것 같아. 하나 차이로 인한 오류처럼 보이니 여기에 –1을 입력해 보겠어. 작동하지 않는 군 그럼 이번에는 a + 1를 대신 넣어봐야겠군, 음, 이번에는 작동하는 것 같군. 이제 문제를 해결했다고 말해야지.” 효과적인 방법은 아니다.

g. 한 번에 한 가지만 변경하라.

h. 수정한 내용을 검사하라

i. 결함을 노출하는 단위 테스트를 추가하라.

j. 유사한 결함을 찾아라.