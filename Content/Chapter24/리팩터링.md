24장 리팩터링

o 프로그램이 초기 개발 시와 초기 배포 후에 변경될 수 있다는 것은 엄연한 인생의 현실이다.

o 소프트웨어는 변경될 때 향상되거나 손상될 수 있다. 소프트웨어 진화의 기본 원칙은 코드가 진화할 때 반드시 내부적인 품질이 향상되어야 한다는 것이다.

o 리팩터링을 성공적으로 수행하기 위한 핵심 요건은 다양한 경고 표시나 리팩터링이 필요하다는 것을 암시하는 냄새에 주의를 기울이는 것이다.

o 리팩터링을 성공적으로 수행하기 위한 또 다른 핵심 요소는 수많은 리팩터링을 학습하는 것이다.

o 리팩터링을 성공적으로 수행하기 위한 마지막 핵심 요소는 리팩터링을 안전하게 수행하기 위한 전략을 갖는 것이다. 어떤 리팩터링 접근 방법은 다른 것보다 더 좋다.

o 개발 중에 리팩터링하면 프로그램을 향상시키고 처음에 만들고자 했던 대로 프로그램을 변경할 수 있는 최고의 기회를 얻게 된다. 개발 중에 그러한 기회를 적극적으로 활용하도록 한다.

 

리팩터링하는 이유

a. 코드가 중복되어 있다.

b. 루프가 너무 길거나 깊이 중첩되어 있다.

- 루프 내부의 구조는 별도의 루틴으로 전환하기에 좋은 후보이며 코드를 더 나은 방법으로 분해하고 루프의 복잡성을 줄일 수 있게 해준다.

c. 클래스의 응집력이 약하다.

- 연관성 없는 여러 가지 기능을 책임지고 있는 클래스를 발견한다면 그 클래스는 서로 관련 있는 역할을 책임질 수 있도록 여러 개의 클래스로 나누어야 한다.

d. 클래스 인터페이스가 일관된 추상화 수준을 제공하지 않는다.

- 클래스가 처음에는 응집력 있는 인터페이스로 시작했더라도 점차 원래의 응집성을 잃을 수 있다. 클래스 인터페이스는 충동적으로 변경하거나 인터페이스의 무결성보다는 편의를 위해 변경하기 때문에 시간이 지나면서 변하기 쉽다.

e. 매개변수가 너무 많다.

f. 클래스 내의 변경 사항이 상호 관계를 고려하지 않고 구분되는 경향이 있다.

- 한 클래스가 두 개 이상의 분명한 책임을 지는 경우도 있다. 클래스의 한 부분이나 다른 부분을 변경했지만, 그러한 변경 사항이 클래스 양쪽 모두에 영향을 미치는 경우가 발생한다. 이는 클래스를 책임별로 여러 개로 나누어야 한다는 신호다.

g. 변경할 때 여러 개의 클래스를 동시에 수정해야 한다.

- 새로운 출력의 종류가 추가될 때마다 수정되어야 하는 15개의 클래스에 대한 목록을 가진 프로젝트가 있었다. 같은 클래스 집합을 일상적으로 변경하고 있다면 변경 사항이 한 클래스에만 영향을 미치도록 클래스에 있는 코드를 재정렬해야 한다.

h. 상속 계층 구조가 병렬로 변경되어야 한다.

- 한 클래스의 서브클래스를 만들 때마다 다른 클래스의 서브클래스를 만드는 것은 특별한 종류의 병렬 수정이며 반드시 해결되어야 한다.

i. case 문이 병렬로 변경되어야 한다.

- case 문이 본질적으로 나쁘지는 않지만, 프로그램 내 여러 곳에서 유사한 case 문을 병렬로 수정하고 있다면 상속이 더 좋은 접근 방법이 아닌지 물어봐야 한다.

j. 함께 사용되는 연관된 데이터 항목이 클래스로 구성되지 않았다.

- 같은 데이터 항목 집합을 반복적으로 처리하고 있다면 그 부분을 고유한 클래스로 결합해야 하는 것은 아닌지 물어봐야 한다.

k. 루틴이 자신이 포함도니 클래스보다 다른 클래스의 기능을 더 많이 사용한다.

- 이럴 때는 해당 루틴을 다른 클래스로 옮기고 이전 클래스로 호출해야 한다.

l. 클래스가 많은 일을 수행하지 않는다.

- 해당 클래스가 처리하는 일이 별로 없어 클래스가 중요하지 않은 것처럼 보인다면 해당 클래스의 책임을 다른 클래스에 넘기고 그 클래스를 삭제하는 것이 좋은지 물어본다.

n. 일련의 루틴이 뜨내기 데이터를 전달한다.

- 특정한 데이터를 전달하는 것이 해당 루틴의 인터페이스가 표현한느 추상화와 일관성이 있는지 자신에게 물어본다. 각 루틴의 추상화에 문제가 없다면 데이터를 전달하는 것도 문제는 없다.

m. 중개 역할을 하는 객체가 아무것도 하지 않는다

- 클래스에 있는 대부분의 코드에서 단순히 다른 클래스에 있는 루틴을 호출하고 있다면 중개 역할을 하는 클래스를 제거하고 다른 클래스를 직접 호출할 수 없는지 고려해 본다.

o. 한 클래스가 다른 클래스를 참견한다.

p. 루틴의 이름이 엉성하다.

q. 공개 데이터 멤버다.

- 인터페이스와 구현 사이의 구분을 흐리게 하며 본질적으로 캡슐화를 위반하고 향후 유연성을 제한한다.

r. 서브클래스는 부모 클래스 루틴의 일부만을 사용한다.

- 전형적으로 이것은 서브클래스가 논리적으로 부모 클래스의 자손이어서가 아니라 부모 클래스가 우연히 서브클래스에서 필요로 하는 루틴을 포함하고 있었기 때문에 서브클래스가 생성되었다는 것을 말해준다. 서브클래스와 슈퍼클래스의 관계를 is-a 관계에서 has-a 관계로 전환해 더 나은 캡슐화를 달성할 수 있는지 고려해 본다.

s. 주석을 이용해 어려운 코드를 설명한다.

t. 전역 변수를 사용한다.

- 전역 변수를 사용하는 코드를 다시 볼 때는 전역 변수를 재평가하는 시간을 갖도록 한다. 어쩌면 전역 변수를 사용하지 않을 수 있는 방법이 떠오를지도 모른다.

u. 루틴이 루틴을 호출하기 전에 설정 코드를 사용하거나 루틴을 호출한 다음에 분해 코드를 사용한다.

루틴 호출에 대한 설정 및 분해 코드를 사용하고 있는 나쁜 C++ 예제

//아래의 설정 코드를 주의한다.

WithdrawalTransaction withdrawal;

withdrawal.SetCustomerId( customerId );

withdrawal.SetBalance( balance );

withdrawal.SetWithdrawalAmount( withdrawalAmount );

withdrawal.SetWithdrawalDate( withdrawalDate );

 

ProcessWithdeawal( withdrawal );

 

//아래의 분해 코드를 주의한다.

customerId = withdrawal.GetCustomerId();

balance = withdrawal.GetBalance();

withdrawalAmount = witdrawal.GetWithdrawalAmount();

withdrawalDate = withdrawal.GetWithdrawalDate();

- 정상적인 초기화 데이터의 일부를 받아들이는 WithdrawalTransaction 클래스에 대한 특별한 생성자를 작성하는 경우에도 주의해야 한다.

메서드 호출에 대한 설정 및 분해 코드를 사용하고 있는 나쁜 C++ 예제

withdrawal = new WithdrawalTransaction( customerId, balance, withdrawalAmount, withdrawalDate );

withdrawal.ProcessWithdrawal();

delete withdrawal;

- 루틴을 호출하기 위한 설정 코드나 루틴을 호출하고 난 후에 분해하는 것을 발견할 때마다 루틴의 인터페이스가 올바른 추상화를 표현하고 있는지 물어봐야 한다. 이 경우에는 ProcessWithdrawal의 매개변수 리스트가 다음과 같은 코드를 지원하도록 수정되어야 한다.

설정 코드나 분해 코드를 요구하지 않는 루틴에 대한 좋은 C++ 예제

ProcessWithdrawal( customerId, balance, withdrawalAmount, withdrawalDate );

- 일반적으로 WithdrawalTransaction 객체를 사용하고 있지만, 다음 코드와 같이 한 루틴에 여러 개의 값을 전달해야 한다면 개별적인 필드를 사용하는 대신 WithdrawalTransaction 객체를 요구하도록 ProcessWithdrawal 인터페이스를 리팩터링하는 것도 고려해야 한다.

여러 개의 메서드 호출이 필요한 코드를 C++로 작성한 예제

ProcessWithdrawal( withdrawal. GetCustomerId(), withdrawal.GetBalance(), withdrawal.GetWithdrawalAmount(), withdrawal.GetWithdrawalDate() );

v. 프로그램이 언젠가 필요할 것 같은 코드를 포함하고 있다.

 

구체적인 리팩터링

데이터 수준 리팩터링

a. 매직 넘버를 이름 상수로 대체

b. 변수 이름을 더 분명하고 많은 정보를 제공하는 이름으로 다시 짓는다.

c. 표현식을 인라인화한다.

- 표현식의 결과를 할당하는 중간 변수를 표현식 자체로 대체한다.

d. 료현식을 루틴으로 대체한다.

e. 중간 변수를 사용한다.

f. 여러 목적으로 사용되는 변수를 단일 목적을 갖는 변수 여러 개로 변환한다.

g. 로컬에서 사용할 목적이라면 매개변수 대신 지역 변수를 사용한다.

h. 기본형 데이터를 클래스로 변환한다.

i. 형 선언 코드 집합을 클래스나 열거형으로 변환한다.

- 독립적인 상수를 정의하는 대신 클래스를 생성해 더 엄격하게 형을 검사하고 필요할 때 OutputType에 더 풍부한 의미를 제공한다. 때로는 열거를 생성하는 것도 클래스 생성에 대한 좋은 대안이다.

j. 배열을 객체로 변경한다.

- 각 요소가 형식이 서로 다른 배열을 사용하고 있다면 배열의 각 요소에 대한 필드를 갖는 객체를 생성한다.

k. 컬렉션을 캡슐화한다.

- 레코드의 멤버를 포함하는 클래스를 생성한다. 클래스를 생성하면 오류 검사와 지속성, 레코드와 관련된 다른 연산에 집중할 수 있다.

 

명령문 수준 리팩터링

a. 불린 표현식을 분해

b. 복잡한 불린 표현식을 명확한 이름의 불린 함수로 옮긴다.

- 표현식이 너무 복잡하다면 이 리팩터링이 가독성을 향상시킬 수 있다. 표현식이 한 번 이상 사용된다면 이렇게 하는 것이 병렬 수정의 필요성을 제거하고 표현식 사용 시 오류 발생 가능성도 줄여준다.

c. 서로 다른 조선문 내에 중복으로 사용된 코드를 결합한다.

d. 루프 제어 변수 대신 break나 return을 사용한다.

e. 중첩된 if-then-else 명령문 내에서 리턴 값을 할당하는 대신, 답을 알았을 때 곧바로 리턴한다.

f. 조건문( 특히 반복되는 case 문 )을 다형성으로 대체한다.

- 구조적인 프로그램에서 case 문에 포함되어 사용되는 많은 논리 구조는 상속 계층으로 구성되어 다형성 루틴 호출을 통해 구현될 수 있다.

g. 널 값을 테스트하는 대신 널 객체를 생성하여 사용한다.

- 때로는 널 객체가 일반적인 행위나 그와 연관된 데이터를 가질 것이다. 예를 들면 이름 모르는 거주자를 “occupant”로 부르는 데이터가 있을 수 있다. 이 경우에는 null 값을 처리하는 책임을 클라이언트가 아닌 클래스로 이동시킨다. 즉, Customer의 클라이언트 코드가 고객의 이름이 알려지지 않았는지 반복해서 테스트하고 아닌 경우 “occupant”로 대체하는 대신 Customer 클래스가 알려지지 않은 거주자를 “occupant”로 정의하게 한다.

 

루틴 수준 리팩터링

a. 루틴을 추출한다 / 메서드를 추출한다.

b. 루틴의 코드를 인라인화한다.

- 코드가 간단하고 자신을 설명하고 있는 루틴에서 코드를 가져다 그것이 사용되는 곳에 루틴의 코드를 넣는다.

c. 긴 루틴을 클래스로 변환한다.

- 루틴이 너무 길다면 떄로는 루틴을 클래스로 변환하고, 이전 루틴을 여러개의 루틴으로 분해하는 것이 가독성을 향상시킬 것이다.

d. 복잡한 알고리즘 대신 간단한 알고리즘을 사용한다.

e. 매개변수를 추가한다.

f. 변경 연산과 쿼리 연산을 구분한다.

- 일반적으로 쿼리 연산은 객체의 상태를 변경하지 않는다. GetTotals() 같은 연산이 객체의 상태를 변경한다면 상태를 변경하는 기능과 쿼리 기능을 분리하고 두 개의 개별 루틴을 제공한다.

g. 매개변수를 이용하여 유사한 루틴을 결합한다.

h. 전달되는 매개변수에 따라 행동하는 루틴을 분리한다.

- 루틴이 입력 매개변수의 값에 따라 서로 다른 코드를 실행하고 있다면 해당 루틴을 특별한 입력 매개변수를 전달하지 않고 개별적으로 실행될 수 있는 루틴으로 나눌 것을 고려해 본다.

i. 특정한 필드 대신 전체 객체를 전달한다.

j. 전체 객체 대신 특정한 필드만 전달한다.

- 단순히 루틴에 전달하려고 객체를 만들었다면, 전체 객체 대신 특정한 필드를 받아들이도록 루틴을 변경할 것을 고려해 본다.

k. 다운캐스팅을 캡슐화한다.

- 루틴이 객체를 리턴하고 있다면 일반적으로 루틴이 알고 있는 가장 구체적인 객체의 형을 리턴해야 한다. 이러한 리팩터링은 특히 반복자(iterator), 컬렉션, 컬렉션의 요소 등을 리턴하는 루틴에 적용할 수 있다.

 

클래스 구현 리팩터링

a. 값 객체를 참조 객체로 변경한다.

- 크거나 복잡한 객체의 복사본을 많이 생성해 관리하고 있다면, 하나의 마스터 객체( 값 객체)만 존재하도록 객체의 사용법을 변경하고 나머지 코드에서는 해당 객체에 대한 참조(참조 객체)만 사용한다.

b. 참조 객체를 값 객체로 변경한다.

- 작고 간단한 객체에 대해 수많은 참조 코드를 수행하고 있다면 모든 객체가 값 객체의 사용법을 변경한다.

c. 가상 루틴을 데이터 초기화로 대체한다.

- 리턴 값만 다른 서브클래스가 있다면 파생 클래스에서 멤버 루틴을 오버라이드하는 대신 파생 클래스에서 적절한 상수 값으로 클래스를 초기화한 후 그 값을 사용할 수 있는 일반적인 코드를 기본 클래스에 넣는다.

d. 멤버 루틴이나 데이터의 위치를 변경한다.

e. 특화된 코드를 서브클래스로 추출한다.

f. 유사한 코드를 서브클래스로 추출한다.

 

클래스 인터페이스 리팩터링

a. 루틴을 다른 클래스로 이동시킨다.

b. 한 클래스를 두 개로 변환한다.

c. 클래스를 제거한다.

- 클래스가 많은 일을 하지 않는다면 해당 클래스의 코드를 더 응집력 있는 다른 클래스로 이동시킨 후 클래스를 제거한다.

d. 위임을 숨긴다.

- 클래스 A는 클래스 B만 호출해야 하고 클래스 B는 클래스 C를 호출해야 하지만, 클래스 A가 클래스 B와 클래스 C를 호출하는 경우가 있다. 이 경우 A가 B를 사용함에 있어 어떻게 추상화해야 할지를 고민해야 한다. 만약 B가 C를 호출해야 하는 기능을 담당하고 있다면 B를 통해 C를 호출하게 한다.

e. 중개자를 제거한다.

f. 상속을 위임으로 대체한다.

- 클래스가 다른 클래스를 사용해야 하지만 클래스의 인터페이스를 제어하고 싶다면 슈퍼클래스를 서브클래스의 필드로 만들고 응집력 있는 추상화를 제공하도록 일련의 루틴을 노출한다.

h. 위임을 상속으로 대체한다.

- 클래스가 위임 클래스( 멤버 클래스 )의 모든 공개 루틴을 노출하고 있다면 클래스를 사용하는 대신 위임 클래스로부터 상속받는다.

i. 확장 클래스를 도입한다.

- 클래스가 여러개의 추가적인 루틴이 필요하지만 해당 클래스를 수정할 수 없다면 수정 불가능한 클래스의 기능과 추가적인 기능을 결합하여 새로운 클래스를 작성할 수 있다. 원본 클래스로부터 서브클래스를 만들어 새로운 루틴을 추가해도 되고 원본 클래스를 래핑한 다음 필요한 루틴을 노출해도 된다.

j. 노출된 멤버 변수를 캡슐화한다.

k. 변경할 수 없는 필드에 대한 Set() 루틴을 제거한다.

l. 클래스 외부에서 사용하면 안 되는 루틴을 숨긴다.

n. 사용되지 않는 루틴을 캡슐화한다.

- 클래스의 특정 인터페이스 부분만 일상적으로 사용한다면 필요한 루틴만 노출하는 새로운 클래스 인터페이스를 생성한다. 새로운 인터페이스가 응집력 있는 추상화를 제공해야 한다.

m. 슈퍼클래스와 서브클래스의 구현이 매우 유사하다면 이 둘을 결합한다.

 

시스템 수준 리팩터링

a. 제어할 수 없는 데이터에 대해 명확한 참조 소스를 생성한다.

- 때로는 편리하게나 일관성 있게 접근할 수 없는 시스템이 관리하는 데이터에 다른 객체가 접근해야 하는 경우가 있다. 흔한 예로 GUI 컨트롤에서 유지되는 데이터가 있다. 그런 경우에는 GUI컨트롤에 있는 데이터를 반영하는 클래스를 생성한 후 GUI컨트롤과 다른 코드가 그 데이터에 대한 명확한 소스로서 해당 클래스를 다루게 할 수 있다.

b. 단방향 클래스 관계를 양방향 클래스 관계로 바꾼다.

c. 양방향 클래스 관계를 단방향 클래스 관계로 바꾼다.

d. 간단한 생성자 대신 팩토리 메서드를 제공한다.

- 형 선언 코드를 기반으로 객체를 생성해야 하거나 값 객체가 아닌 참조 객체를 다루어야 할 때 팩토리 메서드(루틴)를 사용한다.

e. 오류 코드를 예외로 대체하거나 그 반대로 한다.

 

안전한 리팩터링 방법

a. 리팩터링을 시작하기 전에 코드를 저장한다.

b. 리팩터링을 작게 유지한다.

- 어떤 리팩터링은 다른 것보다 변경이 많고 정확하게 무엇이 “하나의 리펙터링”을 구성하는지 분명하지 않을 수 있다. 리펙터링을 작게 유지하여 자신이 변경한 내용이 미치는 영향을 완전하게 이해하고 있어야 한다.

c. 리펙터링은 한 번에 하나만 수행한다.

d. 수행할 단계에 대한 목록을 만든다.

e. 주차장을 만든다.

- 리팩터링을 수행하다가 때로는 다른 리팩터링을 해야 할 것이다. 리팩터링하다가 또 다른 리팩터링이 도움된다는 사실을 알게 될 수도 있다. 지금 당장 필요하지 않은 변경 사항에 대해서는 “주차장”을 만들어 놓는다. “주차장”이란 지금 당장 변경할 ㅍ ᅟᅵᆯ요는 없지만, 어느 시점에서 변경해야 하는 사항에 대한 목록을 말한다.

f. 체크포인트를 자주 설정한다.

g. 컴파일러 경고를 활용한다.

h. 다시 테스트한다.

i. 테스트 케이스를 추가한다.

j. 변경 사항을 검토한다.

k. 리팩터링의 위험 수준에 따라서 접근 방법을 조절한다.